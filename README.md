# üçï `github.com/elliotchance/pie`
[![GoDoc](https://godoc.org/github.com/elliotchance/pie?status.svg)](https://godoc.org/github.com/elliotchance/pie)
[![Build Status](https://travis-ci.org/elliotchance/pie.svg?branch=master)](https://travis-ci.org/elliotchance/pie)
[![codecov](https://codecov.io/gh/elliotchance/pie/branch/master/graph/badge.svg)](https://codecov.io/gh/elliotchance/pie)

**Enjoy a slice!** `pie` is a code generator for dealing with slices that
focuses on type safety, performance and immutability.

- [Quick Start](#quick-start)
  * [Install/Update](#install-update)
  * [Built-in Types](#built-in-types)
  * [Custom Types](#custom-types)
  * [Limiting Functions Generated](#limiting-functions-generated)
- [Functions](#functions)
  * [AreSorted() bool](#aresorted---bool)
  * [AreUnique() bool](#areunique---bool)
  * [Average() float64](#average---float64)
  * [Contains(lookingFor ElementType) bool](#contains-lookingfor-elementtype--bool)
- [FAQ](#faq)
  * [What are the requirements?](#what-are-the-requirements-)
  * [What are the goals of `pie`?](#what-are-the-goals-of--pie--)
  * [How do I contribute a function?](#how-do-i-contribute-a-function-)
  * [Why is the emoji a slice of pizza instead of a pie?](#why-is-the-emoji-a-slice-of-pizza-instead-of-a-pie-)

# Quick Start

## Install/Update

```bash
go get -u github.com/elliotchance/pie
```

## Built-in Types

`pie` ships with some slice types ready to go (pun intended). These include:

- `type`[`Strings`](https://godoc.org/github.com/elliotchance/pie/pie#Strings)`[]string`
- `type`[`Float64s`](https://godoc.org/github.com/elliotchance/pie/pie#Float64s)`[]float64`
- `type`[`Ints`](https://godoc.org/github.com/elliotchance/pie/pie#Ints)`[]int`

These can be used without needing `go generate`. For example:

```go
package main

import (
    "fmt"
    "strings"
    
    "github.com/elliotchance/pie/pie"
)

func main() {
    name := pie.Strings{"Bob", "Sally", "John", "Jane"}.
        Unselect(func (name string) bool {
            return strings.HasPrefix(name, "J")
        }).
        Transform(strings.ToUpper).
        Last()

    fmt.Println(name) // "SALLY"
}
```

## Custom Types

Annotate the slice type in your source code:

```go
type Car struct {
    Name, Color string
}

//go:generate pie Cars.*
type Cars []Car
```

Run `go generate`. This will create a file called `cars_pie.go`. You should
commit this with the rest of your code. Run `go generate` any time you need to
add more types.

Now you can use the slices:

```go
cars := Cars{
    {"Bob", "blue"},
    {"Sally", "green"},
    {"John", "red"},
    {"Jane", "red"},
}

redCars := cars.Select(func(car Car) bool {
    return car.Color == "red"
})

// redCars = Cars{{"John", "red"}, {"Jane", "red"}}
```

Or, more complex operations can be chained:

```go
cars.Unselect(func (car Car) {
        return strings.HasPrefix(car.Name, "J")
    }).
    Transform(func (car Car) Car {
        car.Name = strings.ToUpper(car.Name)
        
        return car
    }).
    Last()

// Car{"SALLY", "green"}
```

## Limiting Functions Generated

The `.*` can be used to generate all functions. This is easy to get going but
creates a lot of unused code. You can limit the functions generated by chaining
the function names with a dot syntax, like:

```go
//go:generate myInts.Average.Sum myStrings.Select
```

This will only generate `myInts.Average`, `myInts.Sum` and `myStrings.Select`.

# Functions

Here is a summary of all of the function. Specific documentation is below.

| Function     | String | Number | Struct| Maps | Big-O    | Description |
| ------------ | :----: | :----: | :----:| :--: | :------: | ----------- |
| `All`        | ‚úì      | ‚úì      | ‚úì     |      | n        | All will return true if all callbacks return true. If the list is empty then true is always returned. |
| `Any`        | ‚úì      | ‚úì      | ‚úì     |      | n        | Any will return true if any callbacks return true. If the list is empty then false is always returned. |
| `Append`     | ‚úì      | ‚úì      | ‚úì     |      | n        | A new slice with the elements appended to the end. |
| `AreSorted`  | ‚úì      | ‚úì      |       |      | n        | Check if the slice is already sorted. |
| `AreUnique`  | ‚úì      | ‚úì      |       |      | n        | Check if the slice contains only unique elements. |
| `Average`    |        | ‚úì      |       |      | n        | The average (mean) value, or a zeroed value. |
| `Bottom`     | ‚úì      | ‚úì      | ‚úì     |      | n        | Gets n elements from bottom. |
| `Contains`   | ‚úì      | ‚úì      | ‚úì     |      | n        | Check if the value exists in the slice. |
| `Extend`     | ‚úì      | ‚úì      | ‚úì     |      | n        | A new slice with the elements from each slice appended to the end. |
| `Each`       | ‚úì      | ‚úì      | ‚úì     |      | n        | Perform an action on each element. |
| `First`      | ‚úì      | ‚úì      | ‚úì     |      | 1        | The first element, or a zeroed value. |
| `FirstOr`    | ‚úì      | ‚úì      | ‚úì     |      | 1        | The first element, or a default value. |
| `Join`       | ‚úì      |        |       |      | n        | A string from joining each of the elements. |
| `JSONString` | ‚úì      | ‚úì      | ‚úì     |      | n        | The JSON encoded string. |
| `Keys`       |        |        |       | ‚úì    | n        | Returns all keys in the map (in random order). |
| `Last`       | ‚úì      | ‚úì      | ‚úì     |      | 1        | The last element, or a zeroed value. |
| `LastOr`     | ‚úì      | ‚úì      | ‚úì     |      | 1        | The last element, or a default value. |
| `Len`        | ‚úì      | ‚úì      | ‚úì     |      | 1        | Number of elements. |
| `Max`        | ‚úì      | ‚úì      |       |      | n        | The maximum value, or a zeroes value. |
| `Median`     |        | ‚úì      |       |      | n‚ãÖlog(n) | Median returns the value separating the higher half from the lower half of a data sample. |
| `Min`        | ‚úì      | ‚úì      |       |      | n        | The minimum value, or a zeroed value. |
| `Reverse`    | ‚úì      | ‚úì      | ‚úì     |      | n        | Reverse elements. |
| `Select`     | ‚úì      | ‚úì      | ‚úì     |      | n        | A new slice containing only the elements that returned true from the condition. |
| `Sort`       | ‚úì      | ‚úì      |       |      | n‚ãÖlog(n) | Return a new sorted slice. |
| `Sum`        |        | ‚úì      |       |      | n        | Sum (total) of all elements. |
| `Shuffle`    | ‚úì      | ‚úì      | ‚úì     |      | n        | Returns a new shuffled slice. |
| `Top`        | ‚úì      | ‚úì      | ‚úì     |      | n        | Gets several elements from top(head of slice).|
| `ToStrings`  | ‚úì      | ‚úì      | ‚úì     |      | n        | Transforms each element to a string. |
| `Transform`  | ‚úì      | ‚úì      | ‚úì     |      | n        | A new slice where each element has been transformed. |
| `Unique`     | ‚úì      | ‚úì      |       |      | n‚ãÖlog(n) | Return a new slice with only unique elements. |
| `Unselect`   | ‚úì      | ‚úì      | ‚úì     |      | n        | A new slice containing only the elements that returned false from the condition. |
| `Values`     |        |        |       | ‚úì    | n        | Returns all values in the map (in random order). |

## All(fn func(value ElementType) bool) bool

All will return true if all callbacks return true. It follows the same logic as
the all() function in Python.

If the list is empty then true is always returned.

## Any(fn func(value ElementType) bool) bool

Any will return true if any callbacks return true. It follows the same logic as
the any() function in Python.

If the list is empty then false is always returned.

## Append(elements ...ElementType) SliceType

Append will return a new slice with the elements appended to the end. It is a
wrapper for the internal append(). It is offered as a function so that it can
more easily chained.

It is acceptable to provide zero arguments.

## AreSorted() bool

AreSorted will return true if the slice is already sorted. It is a wrapper for
`sort.SliceTypeAreSorted`.

## AreUnique() bool

AreUnique will return true if the slice contains elements that are all different
(unique) from each other.

## Average() float64

Average is the average of all of the elements, or zero if there are no elements.

## Bottom(n int) SliceType

Bottom will return n elements from bottom.

That means that elements is taken from the end of the slice for this `[1,2,3]`
slice with n == 2 will be returned `[3,2]`

If the slice has less elements then n that'll return all elements. If n < 0
it'll return empty slice.

## Contains(lookingFor ElementType) bool

Contains returns true if the element exists in the slice.

When using slices of pointers it will only compare by address, not value.

## Each(fn func(ElementType)) SliceType

Each is more condensed version of `Transform` that allows an action to happen on
each elements and pass the original slice on.

```go
cars.Each(func (car *Car) {
	fmt.Printf("Car color is: %s\n", car.Color)
})
```

Pie will not ensure immutability on items passed in so they can be manipulated,
if you choose to do it this way, for example:

```go
// Set all car colors to Red.
cars.Each(func (car *Car) {
	car.Color = "Red"
})
```

## Extend(slices ...SliceType) SliceType

Extend will return a new slice with the slices of elements appended to the end.

It is acceptable to provide zero arguments.

## First() ElementType

First returns the first element, or zero. Also see FirstOr().

## FirstOr(defaultValue ElementType) ElementType

FirstOr returns the first element or a default value if there are no elements.

## Join(glue string) string

Join returns a string from joining each of the elements.

## JSONString() string

JSONString returns the JSON encoded array as a string.

One important thing to note is that it will treat a nil slice as an empty slice
to ensure that the JSON value return is always an array.

## Keys() KeySliceType

Keys returns the keys in the map. All of the items will be unique.

Due to Go's randomization of iterating maps the order is not deterministic.

# FAQ

## What are the requirements?

`pie` supports many Go versions, all the way back to Go 1.8.

## What are the goals of `pie`?

1. **Type safety.** I never want to hit runtime bugs because I could pass in the
wrong type, or perform an invalid type case out the other end.

2. **Performance.** The functions need to be as fast as native Go
implementations otherwise there's no point in this library existing.

3. **Nil-safe.** All of the functions will happily accept nil and treat them as
empty slices. Apart from less possible panics, it makes it easier to chain.

4. **Immutable.** Functions never modify inputs, unlike some built-ins such as
`sort.Strings`.

## How do I contribute a function?

Pull requests are always welcome.

Here is a comprehensive list of steps to follow to add a new function:

1. Create a new file in the `functions/` directory. The file should be named the
same as the function. You must include documentation for your function.

2. Update `functions/main.go` to register the new function by adding an entry to
`Functions`. Make sure you choose the correct `For` value that is appropriate
for your function.

3. Run `go generate ./... && go install && go generate ./...`. The first
`generate` is to create the pie templates, `install` will update your binary for
the annotations and the second `generate` will use the newly created templates
to update the generated code for the internal types. If you encounter errors
with your code you can safely rerun the command above.

4. If you chose `ForAll` or `ForStructs`, then you must add unit tests to
`pie/carpointers_test.go` and `pie/cars_test.go`.

5. If you chose `ForAll`, `ForNumbersAndStrings` or `ForNumbers`, then you must
add unit tests to `pie/float64s_test.go` and `pie/ints_test.go`.

6. If you chose `ForAll` or `ForStrings`, then you must add unit tests to
`pie/strings_test.go`.

7. If you chose `ForMaps`, then you must add unit tests to `pie/currencies.go`.

8. Update the README to list the new functions.

## Why is the emoji a slice of pizza instead of a pie?

I wanted to pick a name for the project that was short and had an associated
emoji. I liked pie, but then I found out that the pie emoji is not fully
supported everywhere. I didn't want to change the name of the project to cake,
but pizza pie still made sense. I'm not sure if I will change it back to a pie
later.
